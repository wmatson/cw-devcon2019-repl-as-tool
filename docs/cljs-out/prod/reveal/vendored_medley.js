// Compiled by ClojureScript 1.10.516 {:static-fns true, :optimize-constants true}
goog.provide('reveal.vendored_medley');
goog.require('cljs.core');
goog.require('cljs.core.constants');
reveal.vendored_medley.medley = cljs.core.list(cljs.core.cst$sym$do,cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$find_DASH_first,"Finds the first item in a collection that matches a predicate.",cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$rf], null),cljs.core.list(cljs.core.cst$sym$fn,cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.list(cljs.core.cst$sym$rf)),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result], null),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result)),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result,cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$pred,cljs.core.cst$sym$x),cljs.core.list(cljs.core.cst$sym$ensure_DASH_reduced,cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,cljs.core.cst$sym$x)),cljs.core.cst$sym$result))))),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$reduce,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$_,cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$pred,cljs.core.cst$sym$x),cljs.core.list(cljs.core.cst$sym$reduced,cljs.core.cst$sym$x))),null,cljs.core.cst$sym$coll))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$dissoc_DASH_in,"Dissociate a value in a nested assocative structure, identified by a sequence\n  of keys. Any collections left empty by the operation will be dissociated from\n  their containing structures.",cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$ks], null),cljs.core.list(cljs.core.cst$sym$if_DASH_let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$k,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$ks], null),cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$ks)], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$ks),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$v,cljs.core.list(cljs.core.cst$sym$dissoc_DASH_in,cljs.core.list(cljs.core.cst$sym$get,cljs.core.cst$sym$m,cljs.core.cst$sym$k),cljs.core.cst$sym$ks)], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$empty_QMARK_,cljs.core.cst$sym$v),cljs.core.list(cljs.core.cst$sym$dissoc,cljs.core.cst$sym$m,cljs.core.cst$sym$k),cljs.core.list(cljs.core.cst$sym$assoc,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v))),cljs.core.list(cljs.core.cst$sym$dissoc,cljs.core.cst$sym$m,cljs.core.cst$sym$k)),cljs.core.cst$sym$m)),cljs.core.list(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$ks,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$kss], null),cljs.core.list(cljs.core.cst$sym$if_DASH_let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$ks_SINGLEQUOTE_,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$kss], null),cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$kss)], null),cljs.core.list(cljs.core.cst$sym$recur,cljs.core.list(cljs.core.cst$sym$dissoc_DASH_in,cljs.core.cst$sym$m,cljs.core.cst$sym$ks),cljs.core.cst$sym$ks_SINGLEQUOTE_,cljs.core.cst$sym$kss),cljs.core.list(cljs.core.cst$sym$dissoc_DASH_in,cljs.core.cst$sym$m,cljs.core.cst$sym$ks)))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$assoc_DASH_some,"Associates a key with a value in a map, if and only if the value is not nil.",cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$nil_QMARK_,cljs.core.cst$sym$v),cljs.core.cst$sym$m,cljs.core.list(cljs.core.cst$sym$assoc,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v))),cljs.core.list(new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$kvs], null),cljs.core.list(cljs.core.cst$sym$reduce,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$k,cljs.core.cst$sym$v], null)], null),cljs.core.list(cljs.core.cst$sym$assoc_DASH_some,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v)),cljs.core.list(cljs.core.cst$sym$assoc_DASH_some,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v),cljs.core.list(cljs.core.cst$sym$partition,(2),cljs.core.cst$sym$kvs)))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$update_DASH_existing,"Updates a value in a map given a key and a function, if and only if the key\n  exists in the map. See: `clojure.core/update`.",new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(cljs.core.cst$sym$quote,cljs.core.list(new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$f,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$args], null))),cljs.core.cst$kw$added,"1.1.0"], null),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$f], null),cljs.core.list(cljs.core.cst$sym$if_DASH_let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$kv,cljs.core.list(cljs.core.cst$sym$find,cljs.core.cst$sym$m,cljs.core.cst$sym$k)], null),cljs.core.list(cljs.core.cst$sym$assoc,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.list(cljs.core.cst$sym$f,cljs.core.list(cljs.core.cst$sym$val,cljs.core.cst$sym$kv))),cljs.core.cst$sym$m)),cljs.core.list(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$f,cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$if_DASH_let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$kv,cljs.core.list(cljs.core.cst$sym$find,cljs.core.cst$sym$m,cljs.core.cst$sym$k)], null),cljs.core.list(cljs.core.cst$sym$assoc,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.list(cljs.core.cst$sym$f,cljs.core.list(cljs.core.cst$sym$val,cljs.core.cst$sym$kv),cljs.core.cst$sym$x)),cljs.core.cst$sym$m)),cljs.core.list(new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$f,cljs.core.cst$sym$x,cljs.core.cst$sym$y], null),cljs.core.list(cljs.core.cst$sym$if_DASH_let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$kv,cljs.core.list(cljs.core.cst$sym$find,cljs.core.cst$sym$m,cljs.core.cst$sym$k)], null),cljs.core.list(cljs.core.cst$sym$assoc,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.list(cljs.core.cst$sym$f,cljs.core.list(cljs.core.cst$sym$val,cljs.core.cst$sym$kv),cljs.core.cst$sym$x,cljs.core.cst$sym$y)),cljs.core.cst$sym$m)),cljs.core.list(new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$f,cljs.core.cst$sym$x,cljs.core.cst$sym$y,cljs.core.cst$sym$z], null),cljs.core.list(cljs.core.cst$sym$if_DASH_let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$kv,cljs.core.list(cljs.core.cst$sym$find,cljs.core.cst$sym$m,cljs.core.cst$sym$k)], null),cljs.core.list(cljs.core.cst$sym$assoc,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.list(cljs.core.cst$sym$f,cljs.core.list(cljs.core.cst$sym$val,cljs.core.cst$sym$kv),cljs.core.cst$sym$x,cljs.core.cst$sym$y,cljs.core.cst$sym$z)),cljs.core.cst$sym$m)),cljs.core.list(new cljs.core.PersistentVector(null, 8, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$f,cljs.core.cst$sym$x,cljs.core.cst$sym$y,cljs.core.cst$sym$z,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$more], null),cljs.core.list(cljs.core.cst$sym$if_DASH_let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$kv,cljs.core.list(cljs.core.cst$sym$find,cljs.core.cst$sym$m,cljs.core.cst$sym$k)], null),cljs.core.list(cljs.core.cst$sym$assoc,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.list(cljs.core.cst$sym$apply,cljs.core.cst$sym$f,cljs.core.list(cljs.core.cst$sym$val,cljs.core.cst$sym$kv),cljs.core.cst$sym$x,cljs.core.cst$sym$y,cljs.core.cst$sym$z,cljs.core.cst$sym$more)),cljs.core.cst$sym$m))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$update_DASH_existing_DASH_in,"Updates a value in a nested associative structure, if and only if the key\n  path exists. See: `clojure.core/update-in`.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$added,"1.3.0"], null),new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$ks,cljs.core.cst$sym$f,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$args], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$up,cljs.core.list(cljs.core.cst$sym$fn,cljs.core.cst$sym$up,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$ks,cljs.core.cst$sym$f,cljs.core.cst$sym$args], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$k,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$ks], null),cljs.core.cst$sym$ks], null),cljs.core.list(cljs.core.cst$sym$if_DASH_let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$kv,cljs.core.list(cljs.core.cst$sym$find,cljs.core.cst$sym$m,cljs.core.cst$sym$k)], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.cst$sym$ks,cljs.core.list(cljs.core.cst$sym$assoc,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.list(cljs.core.cst$sym$up,cljs.core.list(cljs.core.cst$sym$val,cljs.core.cst$sym$kv),cljs.core.cst$sym$ks,cljs.core.cst$sym$f,cljs.core.cst$sym$args)),cljs.core.list(cljs.core.cst$sym$assoc,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.list(cljs.core.cst$sym$apply,cljs.core.cst$sym$f,cljs.core.list(cljs.core.cst$sym$val,cljs.core.cst$sym$kv),cljs.core.cst$sym$args))),cljs.core.cst$sym$m)))], null),cljs.core.list(cljs.core.cst$sym$up,cljs.core.cst$sym$m,cljs.core.cst$sym$ks,cljs.core.cst$sym$f,cljs.core.cst$sym$args))),cljs.core.list(cljs.core.cst$sym$defn_DASH_,cljs.core.cst$sym$editable_QMARK_,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$satisfies_QMARK_,cljs.core.cst$sym$cljs$core$IEditableCollection,cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$defn_DASH_,cljs.core.cst$sym$reduce_DASH_map,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$coll_SINGLEQUOTE_,cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$record_QMARK_,cljs.core.cst$sym$coll),cljs.core.list(cljs.core.cst$sym$into,cljs.core.PersistentArrayMap.EMPTY,cljs.core.cst$sym$coll),cljs.core.cst$sym$coll)], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$editable_QMARK_,cljs.core.cst$sym$coll_SINGLEQUOTE_),cljs.core.list(cljs.core.cst$sym$persistent_BANG_,cljs.core.list(cljs.core.cst$sym$reduce_DASH_kv,cljs.core.list(cljs.core.cst$sym$f,cljs.core.cst$sym$assoc_BANG_),cljs.core.list(cljs.core.cst$sym$transient,cljs.core.list(cljs.core.cst$sym$empty,cljs.core.cst$sym$coll_SINGLEQUOTE_)),cljs.core.cst$sym$coll_SINGLEQUOTE_)),cljs.core.list(cljs.core.cst$sym$reduce_DASH_kv,cljs.core.list(cljs.core.cst$sym$f,cljs.core.cst$sym$assoc),cljs.core.list(cljs.core.cst$sym$empty,cljs.core.cst$sym$coll_SINGLEQUOTE_),cljs.core.cst$sym$coll_SINGLEQUOTE_)))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$map_DASH_entry,"Create a map entry for a key and value pair.",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$cljs$core$MapEntry$,cljs.core.cst$sym$k,cljs.core.cst$sym$v,null)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$map_DASH_kv,"Maps a function over the key/value pairs of an associate collection. Expects\n  a function that takes two arguments, the key and value, and returns the new\n  key and value as a collection of two elements.",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$reduce_DASH_map,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$xf], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$f,cljs.core.cst$sym$k,cljs.core.cst$sym$v)], null),cljs.core.list(cljs.core.cst$sym$xf,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v)))),cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$map_DASH_keys,"Maps a function over the keys of an associative collection.",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$reduce_DASH_map,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$xf], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$xf,cljs.core.cst$sym$m,cljs.core.list(cljs.core.cst$sym$f,cljs.core.cst$sym$k),cljs.core.cst$sym$v))),cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$map_DASH_vals,"Maps a function over the values of one or more associative collections.\n  The function should accept number-of-colls arguments. Any keys which are not\n  shared among all collections are ignored.",cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$reduce_DASH_map,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$xf], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$xf,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.list(cljs.core.cst$sym$f,cljs.core.cst$sym$v)))),cljs.core.cst$sym$coll)),cljs.core.list(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$c1,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$colls], null),cljs.core.list(cljs.core.cst$sym$reduce_DASH_map,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$xf], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$every_QMARK_,cljs.core.list(cljs.core.cst$sym$fn_STAR_,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$p1__13297_SHARP_], null),cljs.core.list(cljs.core.cst$sym$contains_QMARK_,cljs.core.cst$sym$p1__13297_SHARP_,cljs.core.cst$sym$k)),cljs.core.cst$sym$colls),cljs.core.list(cljs.core.cst$sym$xf,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.list(cljs.core.cst$sym$apply,cljs.core.cst$sym$f,cljs.core.cst$sym$v,cljs.core.list(cljs.core.cst$sym$map,cljs.core.list(cljs.core.cst$sym$fn_STAR_,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$p1__13298_SHARP_], null),cljs.core.list(cljs.core.cst$sym$get,cljs.core.cst$sym$p1__13298_SHARP_,cljs.core.cst$sym$k)),cljs.core.cst$sym$colls))),cljs.core.cst$sym$m))),cljs.core.cst$sym$c1))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$map_DASH_kv_DASH_keys,"Maps a function over the key/value pairs of an associative collection, using\n  the return of the function as the new key.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$added,"1.2.0"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$reduce_DASH_map,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$xf], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$xf,cljs.core.cst$sym$m,cljs.core.list(cljs.core.cst$sym$f,cljs.core.cst$sym$k,cljs.core.cst$sym$v),cljs.core.cst$sym$v))),cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$map_DASH_kv_DASH_vals,"Maps a function over the key/value pairs of an associative collection, using\n  the return of the function as the new value.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$added,"1.2.0"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$reduce_DASH_map,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$xf], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$xf,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.list(cljs.core.cst$sym$f,cljs.core.cst$sym$k,cljs.core.cst$sym$v)))),cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$filter_DASH_kv,"Returns a new associative collection of the items in coll for which\n  `(pred (key item) (val item))` returns true.",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$reduce_DASH_map,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$xf], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$pred,cljs.core.cst$sym$k,cljs.core.cst$sym$v),cljs.core.list(cljs.core.cst$sym$xf,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v),cljs.core.cst$sym$m))),cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$filter_DASH_keys,"Returns a new associative collection of the items in coll for which\n  `(pred (key item))` returns true.",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$reduce_DASH_map,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$xf], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$pred,cljs.core.cst$sym$k),cljs.core.list(cljs.core.cst$sym$xf,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v),cljs.core.cst$sym$m))),cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$filter_DASH_vals,"Returns a new associative collection of the items in coll for which\n  `(pred (val item))` returns true.",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$reduce_DASH_map,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$xf], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$pred,cljs.core.cst$sym$v),cljs.core.list(cljs.core.cst$sym$xf,cljs.core.cst$sym$m,cljs.core.cst$sym$k,cljs.core.cst$sym$v),cljs.core.cst$sym$m))),cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$remove_DASH_kv,"Returns a new associative collection of the items in coll for which\n  `(pred (key item) (val item))` returns false.",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$filter_DASH_kv,cljs.core.list(cljs.core.cst$sym$complement,cljs.core.cst$sym$pred),cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$remove_DASH_keys,"Returns a new associative collection of the items in coll for which\n  `(pred (key item))` returns false.",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$filter_DASH_keys,cljs.core.list(cljs.core.cst$sym$complement,cljs.core.cst$sym$pred),cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$remove_DASH_vals,"Returns a new associative collection of the items in coll for which\n  `(pred (val item))` returns false.",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$filter_DASH_vals,cljs.core.list(cljs.core.cst$sym$complement,cljs.core.cst$sym$pred),cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$queue,"Creates an empty persistent queue, or one populated with a collection.",cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.cst$sym$cljs$core$PersistentQueue$EMPTY),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$into,cljs.core.list(cljs.core.cst$sym$queue),cljs.core.cst$sym$coll))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$queue_QMARK_,"Returns true if x implements clojure.lang.PersistentQueue.",new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$instance_QMARK_,cljs.core.cst$sym$cljs$core$PersistentQueue,cljs.core.cst$sym$x)),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$boolean_QMARK_,"Returns true if x is a boolean.",new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$or,cljs.core.list(cljs.core.cst$sym$true_QMARK_,cljs.core.cst$sym$x),cljs.core.list(cljs.core.cst$sym$false_QMARK_,cljs.core.cst$sym$x))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$least,"Return the least argument (as defined by the compare function) in O(n) time.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$arglists,cljs.core.list(cljs.core.cst$sym$quote,cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$xs], null)))], null),cljs.core.list(cljs.core.PersistentVector.EMPTY,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$a], null),cljs.core.cst$sym$a),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$a,cljs.core.cst$sym$b], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$neg_QMARK_,cljs.core.list(cljs.core.cst$sym$compare,cljs.core.cst$sym$a,cljs.core.cst$sym$b)),cljs.core.cst$sym$a,cljs.core.cst$sym$b)),cljs.core.list(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$a,cljs.core.cst$sym$b,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$more], null),cljs.core.list(cljs.core.cst$sym$reduce,cljs.core.cst$sym$least,cljs.core.list(cljs.core.cst$sym$least,cljs.core.cst$sym$a,cljs.core.cst$sym$b),cljs.core.cst$sym$more))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$greatest,"Find the greatest argument (as defined by the compare function) in O(n) time.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$arglists,cljs.core.list(cljs.core.cst$sym$quote,cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$xs], null)))], null),cljs.core.list(cljs.core.PersistentVector.EMPTY,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$a], null),cljs.core.cst$sym$a),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$a,cljs.core.cst$sym$b], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$pos_QMARK_,cljs.core.list(cljs.core.cst$sym$compare,cljs.core.cst$sym$a,cljs.core.cst$sym$b)),cljs.core.cst$sym$a,cljs.core.cst$sym$b)),cljs.core.list(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$a,cljs.core.cst$sym$b,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$more], null),cljs.core.list(cljs.core.cst$sym$reduce,cljs.core.cst$sym$greatest,cljs.core.list(cljs.core.cst$sym$greatest,cljs.core.cst$sym$a,cljs.core.cst$sym$b),cljs.core.cst$sym$more))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$join,"Lazily concatenates a collection of collections into a flat sequence.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$added,"1.1.0"], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$colls], null),cljs.core.list(cljs.core.cst$sym$lazy_DASH_seq,cljs.core.list(cljs.core.cst$sym$when_DASH_let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$s,cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$colls)], null),cljs.core.list(cljs.core.cst$sym$concat,cljs.core.list(cljs.core.cst$sym$first,cljs.core.cst$sym$s),cljs.core.list(cljs.core.cst$sym$join,cljs.core.list(cljs.core.cst$sym$rest,cljs.core.cst$sym$s)))))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$deep_DASH_merge,"Recursively merges maps together. If all the maps supplied have nested maps\n  under the same keys, these nested maps are merged. Otherwise the value is\n  overwritten, as in `clojure.core/merge`.",new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(cljs.core.cst$sym$quote,cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$maps], null))),cljs.core.cst$kw$added,"1.1.0"], null),cljs.core.list(cljs.core.PersistentVector.EMPTY),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$a], null),cljs.core.cst$sym$a),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$a,cljs.core.cst$sym$b], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$and,cljs.core.list(cljs.core.cst$sym$map_QMARK_,cljs.core.cst$sym$a),cljs.core.list(cljs.core.cst$sym$map_QMARK_,cljs.core.cst$sym$b)),cljs.core.list(cljs.core.cst$sym$merge_DASH_with,cljs.core.cst$sym$deep_DASH_merge,cljs.core.cst$sym$a,cljs.core.cst$sym$b),cljs.core.cst$sym$b)),cljs.core.list(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$a,cljs.core.cst$sym$b,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$more], null),cljs.core.list(cljs.core.cst$sym$apply,cljs.core.cst$sym$merge_DASH_with,cljs.core.cst$sym$deep_DASH_merge,cljs.core.cst$sym$a,cljs.core.cst$sym$b,cljs.core.cst$sym$more))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$mapply,"Applies a function f to the argument list formed by concatenating\n  everything but the last element of args with the last element of\n  args. This is useful for applying a function that accepts keyword\n  arguments to a map.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$arglists,cljs.core.list(cljs.core.cst$sym$quote,cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$args], null)))], null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$m], null),cljs.core.list(cljs.core.cst$sym$apply,cljs.core.cst$sym$f,cljs.core.list(cljs.core.cst$sym$apply,cljs.core.cst$sym$concat,cljs.core.cst$sym$m))),cljs.core.list(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$a,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$args], null),cljs.core.list(cljs.core.cst$sym$apply,cljs.core.cst$sym$f,cljs.core.cst$sym$a,cljs.core.list(cljs.core.cst$sym$apply,cljs.core.cst$sym$concat,cljs.core.list(cljs.core.cst$sym$butlast,cljs.core.cst$sym$args),cljs.core.list(cljs.core.cst$sym$last,cljs.core.cst$sym$args))))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$index_DASH_by,"Returns a map of the elements of coll keyed by the result of f on each\n  element. The value at each key will be the last element in coll associated\n  with that key. This function is similar to `clojure.core/group-by`, except\n  that elements with the same key are overwritten, rather than added to a\n  vector of values.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$added,"1.2.0"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$persistent_BANG_,cljs.core.list(cljs.core.cst$sym$reduce,cljs.core.list(cljs.core.cst$sym$fn_STAR_,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$p1__13299_SHARP_,cljs.core.cst$sym$p2__13300_SHARP_], null),cljs.core.list(cljs.core.cst$sym$assoc_BANG_,cljs.core.cst$sym$p1__13299_SHARP_,cljs.core.list(cljs.core.cst$sym$f,cljs.core.cst$sym$p2__13300_SHARP_),cljs.core.cst$sym$p2__13300_SHARP_)),cljs.core.list(cljs.core.cst$sym$transient,cljs.core.PersistentArrayMap.EMPTY),cljs.core.cst$sym$coll))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$interleave_DASH_all,"Returns a lazy seq of the first item in each coll, then the second, etc.\n  Unlike `clojure.core/interleave`, the returned seq contains all items in the\n  supplied collections, even if the collections are different sizes.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$arglists,cljs.core.list(cljs.core.cst$sym$quote,cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$colls], null)))], null),cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.List.EMPTY),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$c1], null),cljs.core.list(cljs.core.cst$sym$lazy_DASH_seq,cljs.core.cst$sym$c1)),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$c1,cljs.core.cst$sym$c2], null),cljs.core.list(cljs.core.cst$sym$lazy_DASH_seq,cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$s1,cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$c1),cljs.core.cst$sym$s2,cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$c2)], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$and,cljs.core.cst$sym$s1,cljs.core.cst$sym$s2),cljs.core.list(cljs.core.cst$sym$cons,cljs.core.list(cljs.core.cst$sym$first,cljs.core.cst$sym$s1),cljs.core.list(cljs.core.cst$sym$cons,cljs.core.list(cljs.core.cst$sym$first,cljs.core.cst$sym$s2),cljs.core.list(cljs.core.cst$sym$interleave_DASH_all,cljs.core.list(cljs.core.cst$sym$rest,cljs.core.cst$sym$s1),cljs.core.list(cljs.core.cst$sym$rest,cljs.core.cst$sym$s2)))),cljs.core.list(cljs.core.cst$sym$or,cljs.core.cst$sym$s1,cljs.core.cst$sym$s2))))),cljs.core.list(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$c1,cljs.core.cst$sym$c2,cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$colls], null),cljs.core.list(cljs.core.cst$sym$lazy_DASH_seq,cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$ss,cljs.core.list(cljs.core.cst$sym$remove,cljs.core.cst$sym$nil_QMARK_,cljs.core.list(cljs.core.cst$sym$map,cljs.core.cst$sym$seq,cljs.core.list(cljs.core.cst$sym$conj,cljs.core.cst$sym$colls,cljs.core.cst$sym$c2,cljs.core.cst$sym$c1)))], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$ss),cljs.core.list(cljs.core.cst$sym$concat,cljs.core.list(cljs.core.cst$sym$map,cljs.core.cst$sym$first,cljs.core.cst$sym$ss),cljs.core.list(cljs.core.cst$sym$apply,cljs.core.cst$sym$interleave_DASH_all,cljs.core.list(cljs.core.cst$sym$map,cljs.core.cst$sym$rest,cljs.core.cst$sym$ss)))))))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$distinct_DASH_by,"Returns a lazy sequence of the elements of coll, removing any elements that\n  return duplicate values when passed to a function f.",cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$rf], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$seen,cljs.core.list(cljs.core.cst$sym$volatile_BANG_,cljs.core.PersistentHashSet.EMPTY)], null),cljs.core.list(cljs.core.cst$sym$fn,cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.list(cljs.core.cst$sym$rf)),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result], null),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result)),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result,cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$fx,cljs.core.list(cljs.core.cst$sym$f,cljs.core.cst$sym$x)], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$contains_QMARK_,cljs.core.list(cljs.core.cst$sym$clojure$core_SLASH_deref,cljs.core.cst$sym$seen),cljs.core.cst$sym$fx),cljs.core.cst$sym$result,cljs.core.list(cljs.core.cst$sym$do,cljs.core.list(cljs.core.cst$sym$vswap_BANG_,cljs.core.cst$sym$seen,cljs.core.cst$sym$conj,cljs.core.cst$sym$fx),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,cljs.core.cst$sym$x))))))))),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$step,cljs.core.list(cljs.core.cst$sym$fn,cljs.core.cst$sym$step,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$xs,cljs.core.cst$sym$seen], null),cljs.core.list(cljs.core.cst$sym$lazy_DASH_seq,cljs.core.list(cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$x,cljs.core.cst$kw$as,cljs.core.cst$sym$xs], null),cljs.core.cst$sym$seen], null),cljs.core.list(cljs.core.cst$sym$when_DASH_let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$s,cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$xs)], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$fx,cljs.core.list(cljs.core.cst$sym$f,cljs.core.cst$sym$x)], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$contains_QMARK_,cljs.core.cst$sym$seen,cljs.core.cst$sym$fx),cljs.core.list(cljs.core.cst$sym$recur,cljs.core.list(cljs.core.cst$sym$rest,cljs.core.cst$sym$s),cljs.core.cst$sym$seen),cljs.core.list(cljs.core.cst$sym$cons,cljs.core.cst$sym$x,cljs.core.list(cljs.core.cst$sym$step,cljs.core.list(cljs.core.cst$sym$rest,cljs.core.cst$sym$s),cljs.core.list(cljs.core.cst$sym$conj,cljs.core.cst$sym$seen,cljs.core.cst$sym$fx))))))),cljs.core.cst$sym$xs,cljs.core.cst$sym$seen)))], null),cljs.core.list(cljs.core.cst$sym$step,cljs.core.cst$sym$coll,cljs.core.PersistentHashSet.EMPTY)))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$dedupe_DASH_by,"Returns a lazy sequence of the elements of coll, removing any **consecutive**\n  elements that return duplicate values when passed to a function f.",cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$rf], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pv,cljs.core.list(cljs.core.cst$sym$volatile_BANG_,cljs.core.cst$kw$reveal$vendored_DASH_medley_SLASH_none)], null),cljs.core.list(cljs.core.cst$sym$fn,cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.list(cljs.core.cst$sym$rf)),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result], null),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result)),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result,cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$prior,cljs.core.list(cljs.core.cst$sym$clojure$core_SLASH_deref,cljs.core.cst$sym$pv),cljs.core.cst$sym$fx,cljs.core.list(cljs.core.cst$sym$f,cljs.core.cst$sym$x)], null),cljs.core.list(cljs.core.cst$sym$vreset_BANG_,cljs.core.cst$sym$pv,cljs.core.cst$sym$fx),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$_EQ_,cljs.core.cst$sym$prior,cljs.core.cst$sym$fx),cljs.core.cst$sym$result,cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,cljs.core.cst$sym$x)))))))),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$f,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$sequence,cljs.core.list(cljs.core.cst$sym$dedupe_DASH_by,cljs.core.cst$sym$f),cljs.core.cst$sym$coll))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$take_DASH_upto,"Returns a lazy sequence of successive items from coll up to and including\n  the first item for which `(pred item)` returns true.",cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$rf], null),cljs.core.list(cljs.core.cst$sym$fn,cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.list(cljs.core.cst$sym$rf)),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result], null),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result)),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result,cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result,cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,cljs.core.cst$sym$x)], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$pred,cljs.core.cst$sym$x),cljs.core.list(cljs.core.cst$sym$ensure_DASH_reduced,cljs.core.cst$sym$result),cljs.core.cst$sym$result)))))),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$lazy_DASH_seq,cljs.core.list(cljs.core.cst$sym$when_DASH_let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$s,cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$coll)], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$x,cljs.core.list(cljs.core.cst$sym$first,cljs.core.cst$sym$s)], null),cljs.core.list(cljs.core.cst$sym$cons,cljs.core.cst$sym$x,cljs.core.list(cljs.core.cst$sym$if_DASH_not,cljs.core.list(cljs.core.cst$sym$pred,cljs.core.cst$sym$x),cljs.core.list(cljs.core.cst$sym$take_DASH_upto,cljs.core.cst$sym$pred,cljs.core.list(cljs.core.cst$sym$rest,cljs.core.cst$sym$s))))))))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$drop_DASH_upto,"Returns a lazy sequence of the items in coll starting *after* the first item\n  for which `(pred item)` returns true.",cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$rf], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$dv,cljs.core.list(cljs.core.cst$sym$volatile_BANG_,true)], null),cljs.core.list(cljs.core.cst$sym$fn,cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.list(cljs.core.cst$sym$rf)),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result], null),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result)),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result,cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$clojure$core_SLASH_deref,cljs.core.cst$sym$dv),cljs.core.list(cljs.core.cst$sym$do,cljs.core.list(cljs.core.cst$sym$when,cljs.core.list(cljs.core.cst$sym$pred,cljs.core.cst$sym$x),cljs.core.list(cljs.core.cst$sym$vreset_BANG_,cljs.core.cst$sym$dv,false)),cljs.core.cst$sym$result),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,cljs.core.cst$sym$x))))))),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$pred,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$rest,cljs.core.list(cljs.core.cst$sym$drop_DASH_while,cljs.core.list(cljs.core.cst$sym$complement,cljs.core.cst$sym$pred),cljs.core.cst$sym$coll)))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$indexed,"Returns an ordered, lazy sequence of vectors `[index item]`, where item is a\n  value in coll, and index its position starting from zero.",cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$rf], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$i,cljs.core.list(cljs.core.cst$sym$volatile_BANG_,(-1))], null),cljs.core.list(cljs.core.cst$sym$fn,cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.list(cljs.core.cst$sym$rf)),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result], null),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result)),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result,cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$vswap_BANG_,cljs.core.cst$sym$i,cljs.core.cst$sym$inc),cljs.core.cst$sym$x], null))))))),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$map_DASH_indexed,cljs.core.cst$sym$vector,cljs.core.cst$sym$coll))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$insert_DASH_nth,"Returns a lazy sequence of the items in coll, with a new item inserted at\n  the supplied index, followed by all subsequent items of the collection. Runs\n  in O(n) time.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$added,"1.2.0"], null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$index,cljs.core.cst$sym$item], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$rf], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$idx,cljs.core.list(cljs.core.cst$sym$volatile_BANG_,cljs.core.list(cljs.core.cst$sym$inc,cljs.core.cst$sym$index))], null),cljs.core.list(cljs.core.cst$sym$fn,cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.list(cljs.core.cst$sym$rf)),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$_EQ_,cljs.core.list(cljs.core.cst$sym$clojure$core_SLASH_deref,cljs.core.cst$sym$idx),(1)),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,cljs.core.cst$sym$item)),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result))),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result,cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$zero_QMARK_,cljs.core.list(cljs.core.cst$sym$vswap_BANG_,cljs.core.cst$sym$idx,cljs.core.cst$sym$dec)),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,cljs.core.cst$sym$item),cljs.core.cst$sym$x),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,cljs.core.cst$sym$x))))))),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$index,cljs.core.cst$sym$item,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$lazy_DASH_seq,cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$zero_QMARK_,cljs.core.cst$sym$index),cljs.core.list(cljs.core.cst$sym$cons,cljs.core.cst$sym$item,cljs.core.cst$sym$coll),cljs.core.list(cljs.core.cst$sym$when,cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$coll),cljs.core.list(cljs.core.cst$sym$cons,cljs.core.list(cljs.core.cst$sym$first,cljs.core.cst$sym$coll),cljs.core.list(cljs.core.cst$sym$insert_DASH_nth,cljs.core.list(cljs.core.cst$sym$dec,cljs.core.cst$sym$index),cljs.core.cst$sym$item,cljs.core.list(cljs.core.cst$sym$rest,cljs.core.cst$sym$coll)))))))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$remove_DASH_nth,"Returns a lazy sequence of the items in coll, except for the item at the\n  supplied index. Runs in O(n) time.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$added,"1.2.0"], null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$index], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$rf], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$idx,cljs.core.list(cljs.core.cst$sym$volatile_BANG_,cljs.core.list(cljs.core.cst$sym$inc,cljs.core.cst$sym$index))], null),cljs.core.list(cljs.core.cst$sym$fn,cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.list(cljs.core.cst$sym$rf)),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result], null),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result)),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result,cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$zero_QMARK_,cljs.core.list(cljs.core.cst$sym$vswap_BANG_,cljs.core.cst$sym$idx,cljs.core.cst$sym$dec)),cljs.core.cst$sym$result,cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,cljs.core.cst$sym$x))))))),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$index,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$lazy_DASH_seq,cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$zero_QMARK_,cljs.core.cst$sym$index),cljs.core.list(cljs.core.cst$sym$rest,cljs.core.cst$sym$coll),cljs.core.list(cljs.core.cst$sym$when,cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$coll),cljs.core.list(cljs.core.cst$sym$cons,cljs.core.list(cljs.core.cst$sym$first,cljs.core.cst$sym$coll),cljs.core.list(cljs.core.cst$sym$remove_DASH_nth,cljs.core.list(cljs.core.cst$sym$dec,cljs.core.cst$sym$index),cljs.core.list(cljs.core.cst$sym$rest,cljs.core.cst$sym$coll)))))))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$replace_DASH_nth,"Returns a lazy sequence of the items in coll, with a new item replacing the\n  item at the supplied index. Runs in O(n) time.",new cljs.core.PersistentArrayMap(null, 1, [cljs.core.cst$kw$added,"1.2.0"], null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$index,cljs.core.cst$sym$item], null),cljs.core.list(cljs.core.cst$sym$fn,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$rf], null),cljs.core.list(cljs.core.cst$sym$let,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$idx,cljs.core.list(cljs.core.cst$sym$volatile_BANG_,cljs.core.list(cljs.core.cst$sym$inc,cljs.core.cst$sym$index))], null),cljs.core.list(cljs.core.cst$sym$fn,cljs.core.list(cljs.core.PersistentVector.EMPTY,cljs.core.list(cljs.core.cst$sym$rf)),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result], null),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result)),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$result,cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$zero_QMARK_,cljs.core.list(cljs.core.cst$sym$vswap_BANG_,cljs.core.cst$sym$idx,cljs.core.cst$sym$dec)),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,cljs.core.cst$sym$item),cljs.core.list(cljs.core.cst$sym$rf,cljs.core.cst$sym$result,cljs.core.cst$sym$x))))))),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$index,cljs.core.cst$sym$item,cljs.core.cst$sym$coll], null),cljs.core.list(cljs.core.cst$sym$lazy_DASH_seq,cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$zero_QMARK_,cljs.core.cst$sym$index),cljs.core.list(cljs.core.cst$sym$cons,cljs.core.cst$sym$item,cljs.core.list(cljs.core.cst$sym$rest,cljs.core.cst$sym$coll)),cljs.core.list(cljs.core.cst$sym$when,cljs.core.list(cljs.core.cst$sym$seq,cljs.core.cst$sym$coll),cljs.core.list(cljs.core.cst$sym$cons,cljs.core.list(cljs.core.cst$sym$first,cljs.core.cst$sym$coll),cljs.core.list(cljs.core.cst$sym$replace_DASH_nth,cljs.core.list(cljs.core.cst$sym$dec,cljs.core.cst$sym$index),cljs.core.cst$sym$item,cljs.core.list(cljs.core.cst$sym$rest,cljs.core.cst$sym$coll)))))))),cljs.core.list(cljs.core.cst$sym$defn,cljs.core.cst$sym$abs,"Returns the absolute value of a number.",new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$x], null),cljs.core.list(cljs.core.cst$sym$if,cljs.core.list(cljs.core.cst$sym$neg_QMARK_,cljs.core.cst$sym$x),cljs.core.list(cljs.core.cst$sym$_DASH_,cljs.core.cst$sym$x),cljs.core.cst$sym$x)));
